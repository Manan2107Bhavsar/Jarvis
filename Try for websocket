import asyncio
import websockets
import json
import logging
from datetime import datetime
from typing import Set, Dict
import uuid

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class WebSocketServer:
    def __init__(self):
        self.clients: Dict[str, websockets.WebSocketServerProtocol] = {}
        self.rooms: Dict[str, Set[str]] = {}

    async def register_client(self, websocket, client_id: str):
        """Register a new client connection"""
        self.clients[client_id] = websocket
        logger.info(f"Client {client_id} connected. Total clients: {len(self.clients)}")

        # Send welcome message
        await websocket.send(json.dumps({
            "type": "welcome",
            "client_id": client_id,
            "timestamp": datetime.now().isoformat()
        }))

    async def unregister_client(self, client_id: str):
        """Remove client from registry"""
        if client_id in self.clients:
            del self.clients[client_id]

            # Remove from all rooms
            for room in self.rooms.values():
                room.discard(client_id)

            logger.info(f"Client {client_id} disconnected. Remaining clients: {len(self.clients)}")

    async def broadcast_message(self, message: dict, exclude_client: str = None):
        """Broadcast message to all connected clients"""
        if self.clients:
            message_str = json.dumps(message)
            tasks = []

            for client_id, websocket in self.clients.items():
                if client_id != exclude_client:
                    tasks.append(websocket.send(message_str))

            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)

    async def handle_client(self, websocket, path):
        """Handle individual client connection"""
        client_id = str(uuid.uuid4())

        try:
            await self.register_client(websocket, client_id)

            async for message in websocket:
                try:
                    data = json.loads(message)
                    await self.process_message(client_id, data)
                except json.JSONDecodeError:
                    await websocket.send(json.dumps({
                        "type": "error",
                        "message": "Invalid JSON format"
                    }))
                except Exception as e:
                    logger.error(f"Error processing message: {e}")

        except websockets.exceptions.ConnectionClosed:
            logger.info(f"Client {client_id} connection closed")
        finally:
            await self.unregister_client(client_id)

    async def process_message(self, client_id: str, data: dict):
        """Process incoming client messages"""
        message_type = data.get("type")

        if message_type == "broadcast":
            await self.broadcast_message({
                "type": "message",
                "from": client_id,
                "content": data.get("content"),
                "timestamp": datetime.now().isoformat()
            }, exclude_client=client_id)

        elif message_type == "join_room":
            room_name = data.get("room")
            if room_name:
                if room_name not in self.rooms:
                    self.rooms[room_name] = set()
                self.rooms[room_name].add(client_id)

                await self.clients[client_id].send(json.dumps({
                    "type": "room_joined",
                    "room": room_name
                }))

        elif message_type == "room_message":
            room_name = data.get("room")
            if room_name in self.rooms:
                message = {
                    "type": "room_message",
                    "room": room_name,
                    "from": client_id,
                    "content": data.get("content"),
                    "timestamp": datetime.now().isoformat()
                }

                for member_id in self.rooms[room_name]:
                    if member_id in self.clients and member_id != client_id:
                        await self.clients[member_id].send(json.dumps(message))

    async def start_server(self, host="localhost", port=8765):
        """Start the WebSocket server"""
        logger.info(f"Starting WebSocket server on {host}:{port}")
        async with websockets.serve(self.handle_client, host, port):
            await asyncio.Future()  # Run forever

# Run the server
if __name__ == "__main__":
    server = WebSocketServer()
    asyncio.run(server.start_server())